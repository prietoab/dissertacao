\chapter{Materiais e Métodos\label{cap:metodologia}}

	A metodologia teve três pilares: sólida base em Algoritmos Genéticos, estudo detalhado dos artigos e desenvolvimento de um \emph{software} confiável para execução do modelo. Os três são apresentados nas seções seguintes.

%========================================================
\section{Algoritmos Genéticos}\label{seq:medologia_ga}
%========================================================
	
	Iniciei os estudos em Algoritmos Genéticos pelos livros \cite{Mitchell98} e \cite{Linden2008} e, antes de partir para o trabalho da dissertação em si, ataquei três problemas completamente distintos.
	
	O primeiro foi o ONEMAX \cite{onemaxNaGPU}, desenvolvido ``do zero'', em Linguagem C. Considerado o \emph{hello world} do GA, tem representação cromossomial binária, o \emph{fitness} é a soma dos \emph{bits} de cada indivíduo e o objetivo é obter um indivíduo com o maior número de '1' possível. Com ele pude estudar os parâmetros de um GA simples, como número de indivíduos e a probabilidade de \emph{crossover}, e verificar a influência de cada um na qualidade da solução, convergência, desempenho, evolução do \emph{fitness} etc. Uma versão paralelizada em CUDA foi apresentada em evento de computação de alto desempenho \cite{ERAD12} e é discutida na seção \ref{sec:oneMaxNaGPU}.
	
	\begin{figure}[htbp]
		\centering
			\includegraphics[width=0.60\textwidth]{figs/resultados/onemax/onemax_objetivo.png}
		\caption{ONEMAX: representação cromossomial, \emph{fitness} e objetivo.}
		\label{fig:onemax_objetivo_metodologia}
	\end{figure}
	
	Tendo a estrutura básica do ONEMAX, o próximo passo foi tentar fazer um modelo. Abordei o Problema das Oito Rainhas, que consiste em posicionar oito rainhas em um tabuleiro de xadrez de modo que não se ataquem. Sem nenhuma referência externa, propus um modelo de GA que conseguiu chegar em algumas soluções \cite{qualificacao_adriano}. Uma delas está na figura \ref{fig:OitoRainhasSolucao}.
	
	\begin{figure}[htbp]
		\centering
			\includegraphics[width=0.30\textwidth]{figs/materiais_metodo/ga/OitoRainhasSolucao.png}
		\caption{Uma solução para o Problema das 8 Rainhas.}
		\label{fig:OitoRainhasSolucao}
	\end{figure}
	
	Tratando o tabuleiro de xadrez como um plano cartesiano, a representação cromossomial era um \emph{string} com os oito pares de coordenadas $(x,y)$. Cada coordenada gerava uma matriz característica de 0's e 1's que, quando somadas, resultava em uma matriz com a informação da quantidade $c$ de ataques que cada rainha sofreu. O objetivo, portanto, era encontrar um indivíduo que levasse a $c = 0$. A função de avaliação foi definida como $f = 1/(1 + c)$.
	
	Criar um modelo para o Oito Rainhas foi importante para o entendimento do elo entre um GA e o problema a ser resolvido. Essa ligação encontra-se na representação cromossomial e na função de avaliação. Defini ambas de maneira adequada, mas a representação cromossomial apresentou um problema: nada impede de haver pontos $(x,y)$ repetidos no cromossomo. Em outras palavras, ela permite que duas rainhas sejam colocadas na mesma posição do tabulareiro, o que é proibido no xadrez. 
	
	Por fim, utilizei GA na criação de um robô, chamado \emph{Genético}, para ser testado contra os campeões do torneio de Robocode da Faculdade de Tecnologia da Unicamp\footnote{\texttt{http://torneiorobocode.orgfree.com/torneio-ft.php}}. Robocode é um jogo\footnote{\texttt{http://robocode.sourceforge.net/}}, cujo objetivo é programar um tanque de guerra robô para competir contra outros robôs em uma arena de batalha. Ele começou como um projeto pessoal no ano 2000 e depois foi incorporado pela IBM\footnote{\texttt{http://robocode.sourceforge.net/docs/ReadMe.html}}. Atualmente é um projeto de código aberto.
	
	\begin{figure}[htbp]
		\centering
			\includegraphics[width=0.50\textwidth]{figs/materiais_metodo/ga/Robocode_Battle_Field.PNG}
		\caption{Arena de batalha do Robocode.}
		\label{fig:Robocode}
	\end{figure}
	
	Me baseei no artigo \cite{robocodeGA}, publicado em um congresso de computação evolutiva da IEEE. As primeiras versões do \emph{Genético} não travaram boas batalhas. Alterei o \emph{fitness} e o processo de treinamento. Na versão final o ele foi capaz de vencer os robôs que ficaram em primeiro e terceiro lugar no torneio daquele ano (o segundo lugar não estava disponível para \emph{download}). O \emph{Genético} vencia, inclusive, contra os dois simultaneamente \cite{robocodeGA_adriano}.
	
%========================================================
\section{Autovalores de Hamiltonianos com Algoritmos Genéticos\label{sec:metodo}}
%========================================================

	Os métodos que estudei nessa dissertação estão contidos em uma série de artigos \cite{metodo2002, metodo2004, metodo2006, metodo2008, metodo2009, metodo2011}. O objetivo é encontrar, sequencialmente, do menor para o maior, os autovalores de uma matriz simétrica. Essa matriz é o Hamiltoniano presente na formulação matricial da equação de Schrödinger independente do tempo\footnote{Ela é importante para a física moderna pois está associada à quantização da energia na Mecânica Quântica. No apêndice \ref{apdc:eqSchr} há uma breve exposição de como essa equação diferencial parcial pode ser escrita como um problema de autovalores e autovetores.}. A estratégia é transformar o problema do autovalor em um problema de otimização, buscando um escalar $a_i$ e um vetor $X_i$ de modo que a equaçaõ $HX_i = a_iX_i$ seja satisfeita.
	
	Os algoritmos apresentados em \cite{metodo2004} e \cite{metodo2011} são mais simples. Por exemplo, em \cite{metodo2002} o Hamiltoniano é alterado por rotações de Jacobi e, só então, o \emph{fitness} é calculado. Nos artigos \cite{metodo2006}, \cite{metodo2008} e \cite{metodo2009} o espaço vetorial é dividido em duas partes de dimensões diferentes, levando a um Hamiltoniano que contém alguns autovalores de interesse\footnote{\emph{Partitioned matrix eigenvalue problem.}}. Isso não ocorre com os GAs das publicações de 2004 e 2011. Nelas o Hamiltoniano original é sempre mantido.
	
	Pode-se dizer que \cite{metodo2011} é a continuação de \cite{metodo2004}. A representação cromossomial e os operadores de seleção, \emph{crossover} e mutação são os mesmos. No entanto, ele adiciona dois operadores genéticos. O primeiro é complementar à mutação, e atua para criar mais diversidade na população. O segundo acentua a pressão seletiva via Elitismo. Não há justificativa para os novos operadores. Acredito que o intuito tenha sido melhorar a qualidade dos resultados, mas, infelizmente, não há comparação com os obtidos em 2004. E, de fato, isso seria impossível, pois em 2011 há uma mudança drástica: a função de avaliação foi alterada. Além disso, \cite{metodo2011} paraleliza o GA e compara os desempenhos.
	
	Assim, optei por seguir estritamente o processo e os operadores discutidos em \cite{metodo2004}, mas utilizar, também, o \emph{fitness} do \cite{metodo2011}. Ao manter o mesmo GA, foi possível comparar com segurança os resultados das duas funções de avaliação.

%========================================================	
\section{Descrição do Algoritmo}
%========================================================	

	Há casos em que não há solução exata para a equação de Schrödinger independente do tempo. Quando isso acontece, é preciso introduzir uma base ortonormal finita {$\phi$} e expandir o estado estacionário $\psi$ em termos dos vetores geradores dessa base
	
	\begin{equation}
		\psi = \sum_k c_k \phi_k.
	\end{equation}
	
	Isso leva ao problema de autovalores
	
	\begin{equation}\label{eq:HCEC}
		HC = EC,
	\end{equation}
	onde $H$ é uma matriz real e simétrica, construída na base ${\phi}$, que representa o operador Hamiltoniano. A diagonalização de $H$ encontra os autovalores $E_n$ correspondentes às energias possíveis do sistema quântico. Com isso, é possível obter os autovetores (autoestados) $C_n$ associados.
	
	No artigo \cite{metodo2004} é apresentada uma maneira de reduzir o problema de autovalores a um problema de busca. Dados todos os vetores $C$ existentes na base $\phi$, conjunto chamado de \textbf{Espaço de Busca}, o objetivo é encontrar os autovetores $C_n$ que satisfaçam a equação \ref{eq:HCEC}. O conjunto de todos os autovetores $C_n$ é o \textbf{Espaço de Soluções}. O mecanismo de busca é um algoritmo genético (GA).
	
	Conforme visto no capítulo \ref{cap:ga}, o elo entre o GA e o problema a ser resolvido está na Representação Cromossomial e na Função de Avaliação. O cromossomo deve codificar a solução desejada na forma de um \emph{string}, seja de caracteres, símbolos, números inteiros ou reais. O \emph{fitness} deve ser capaz de definir, objetivamente, a qualidade de todos os indivíduos da população, de modo que seja possível comparar cada um com as soluções desejadas. Quanto mais próximo um cromossomo está da solução, mais alto deve ser seu \emph{fitness}.

%-------------------------------------------------------		
	\subsection{Representação Cromossomial}
%-------------------------------------------------------	
	
	Como solução pretendida é um autovetor, o cromossomo codifica um vetor. Cada indivíduo $i$ da população é um vetor $\psi_i$ candidato à autovetor na forma
	
	\begin{equation}
		\psi_i = \sum_{p=1}^m c_{pi}\phi_p, \mbox{   } i = 1,2, \cdots, n
	\end{equation}
	
	Na equação acima, $i$ varia de 1 até o número máximo de indivíduos na população do GA, mantida fixa ao longo de toda a execução. O índice $p$ é tomado de 1 até a $m$, que é ordem da matriz $H$ (ou a dimensão do espaço vetorial).
	
	O cromossomo é definido como uma cadeia de números reais, cujos valores são os coeficientes $c_{pi}$. O \emph{string} $S_i$, codificação para o membro $\psi_i$, é dado por
	
	\begin{equation}
		S_i \equiv  (c_{1i}, c_{2i}, \cdots, c_{pi}, \cdots, c_{mi}) = C^{\dagger}_i,
	\end{equation}
	enquanto que para outro membro $\psi_k$ da população, o \emph{string} $S_k$ é
	
	\begin{equation}
		S_k \equiv  (c_{1k}, c_{2k}, \cdots, c_{pk}, \cdots, c_{mk}) = C^{\dagger}_k.
	\end{equation}
	
%-------------------------------------------------------
	\subsection{População}
%-------------------------------------------------------

	A população inicial é gerada aleatoriamente. Não há nenhuma preferência com relação aos valores iniciais de cada gene.
	
	Seu tamanho (número de indivíduos) é sempre mantido fixo a cada nova geração.
	
%-------------------------------------------------------
	\subsection{Funções de Avaliação (\emph{fitness})}
	\label{sec:fitness_metodo}
%-------------------------------------------------------	

	O \emph{fitness} proposto em \cite{metodo2004} é obtido em três passos:
	
	\begin{enumerate}
		\item \label{item:passo1} Cálculo do quociente de Rayleigh $\rho_i$ associado ao $i-$ésimo indivíduo $C_i$;
		\item \label{item:passo2} Cálculo do gradiente de $\rho_i$;
		\item \label{item:passo3} Cálculo da função de avaliação.
	\end{enumerate}
	
	Retomando o capítulo \ref{cap:algebra}, o quociente de Rayleigh é dado por
	
	\begin{equation}
		\rho_i = \frac{C_i^\dagger H C_i}{C_i^\dagger C_i},
	\end{equation}
	e seu gradiente por
	
	\begin{equation}\label{eq:grad_rho_metodo}
		\nabla \rho_i = \frac{2[H - \rho_i]C_i}{C_i^\dagger C_i}.
	\end{equation}
		
	O \emph{fitness} é então definido como \footnote{
		No artigo \cite{metodo2004} a equação originalmente apresentada é $f_i = e^{-\lambda (\nabla \rho_i)^{\nabla \rho_i}}$. Acredito que tenha sido um erro de digitação por dois motivos. O primeiro é que tal definição não leva, necessariamente, ao comportamento esperado: $f_i \rightarrow 1$ quando $\nabla \rho_i \rightarrow 0$. Em segundo lugar, nos artigos \cite{metodo2006},  \cite{metodo2008} e \cite{metodo2009}, que seguem o mesmo método, a função de avaliação é definida como $f_i = e^{-\lambda (\nabla \rho_i)^{\dagger} (\nabla \rho_i)}$. Portanto, segui com a definição de $f_i$ da equação \ref{eq:fitness_extenso}.}
	
	\begin{equation}\label{eq:fitness_extenso}
		f_i = e^{-\lambda (\nabla \rho_i)^\dagger (\nabla \rho_i)}.
	\end{equation}
	
	Lembrando que o módulo de um vetor $V$ é dado por $|V| = \sqrt{V^{\dagger} V}$, a equação \ref{eq:fitness_extenso} fica
	
	\begin{equation}\label{eq:fitness_grad}
		f_i(\nabla \rho_i) = e^{-\lambda |\nabla \rho_i|^2}.
	\end{equation}
			 
	A função de avaliação $f_i$ está limitada entre zero e um, $f_i$ = (0,1]. Se $|\nabla \rho|^2 \gg 0$, $f_i \rightarrow 0$, indicando que $C_i$ possui baixa qualidade, está longe da solução. Por outro lado, se $\nabla \rho_i \rightarrow 0 $, $f_i \rightarrow 1$, e $C_i$ é uma boa aproximação para um autovetor. O parâmetro $\lambda$ é escolhido para não haver \emph{over flow} ou \emph{under flow} da função exponencial.
	
	De acordo com os autores, a equação \ref{eq:fitness_grad} leva ao autovalor mínimo. Se algum $C_i$, em algum momento, é o autovetor fundamental $C_0$, o $\nabla \rho$ é nulo. Eles afirmam que ``\textit{Claramente, $f_i \rightarrow 1$ quando $\nabla \rho_i \rightarrow 0$, sinalizando que a evolução atingiu o verdadeiro autovetor fundamental de $H$ em $C_i$}''\footnote{Tradução livre de ``\textit{Clearly, $f_i \rightarrow 1$, as $\nabla \rho_i \rightarrow 0$, signalling that the evolution has hit the true ground state eigenvector of $H$ in the vector $C_i$}''.}. 
	
	Uma vez que $C_0$ foi encontrado, o próximo passo é obter o autovalor $E_0$ associado. Na verdade ele já foi calculado, e é simplesmente o valor do quociente de Rayleigh para $C_i$:
	
	\begin{equation}
		\rho_0 = \frac{C_i^{\dagger} H C_i}{C_i^{\dagger} C_i} = E_0.
	\end{equation}
	
	Quando o algoritmo chega nesse estágio tem-se o par $(C_0,E_0)$.
	
	Como já dito anteriormente, a função de avaliação foi alterada em \cite{metodo2011}, e é dada por 
	
	\begin{equation}\label{eq:fitness_EL_metodo}
		f_i(\rho_i) = e^{-\lambda(\rho_i - E_L)^2},
	\end{equation}
	onde $E_L$ é um limite inferior para o autovalor mínimo procurado.
	
	Ela compartilha algumas propriedades com a equação \ref{eq:fitness_grad}. Está limitada no conjunto $f_i(\rho) = (0,1]$ e, quanto maior seu valor, melhor a qualidade do indivíduo. O parâmetro $\lambda$ tem exatamente a mesma função. A busca utilizando $f_i(\rho)$ também termina quando $f_i \rightarrow 1$. ``\emph{Se $\rho_i \rightarrow E_L$ durante a busca, $f_i \rightarrow 1$ and $C_i$ se aproxima do autovetor fundamental de $H$}''. Novamente, como já temos $C_0$, o autovalor $E_0$ é simplesmente o $\rho_i$ já calculado.	O cálculo de $f_i(\rho)$ executa os passos \ref{item:passo1} e \ref{item:passo3} de $f_i(\nabla\rho)$.
				
		A não ser por acidente, a condição $f_i \rightarrow 1$ não é satisfeita logo na primeira população. É necessário evoluir os indivíduos por meio dos operadores genéticos de seleção, reprodução e mutação. Eles serão apresentados nas seções seguintes.

%-------------------------------------------------------
\subsection{Seleção}
%-------------------------------------------------------	

			O operador de seleção utilizado tanto em \cite{metodo2004} quanto em \cite{metodo2011} é o da Roleta, com fatias proporcionais aos valores do \emph{fitness} \cite{Linden2008}. Se a população possui $q$ indivíduos, a roleta é ``girada'' $q$ vezes, de modo a criar a nova população com os $q$ cromossomos selecionados.
			
			Entretanto, utilizei a seleção por Torneio pelos motivos apresentados na seção \ref{sec:torneio}. Mantive o tamanho da população fixa.
									
%-------------------------------------------------------
\subsection{Reprodução}
%-------------------------------------------------------

	A operação de reprodução ($crossover$) é aplicada na nova população após a Seleção. Há diferença entre os operadores de reprodução de \cite{metodo2004} e \cite{metodo2011}. Apresentarei ambos e, ao final, justificarei porque escolhi como base o segundo.

%----------------------------------------------------	
\subsubsection{\emph{Crossover} em \cite{metodo2004}}
%----------------------------------------------------	
	
	Suponha que tenham sido escolhidos, aleatoriamente, um par de cromossomos ($S_k$, $S_l$) dentre todos os $N$ indivíduos da população:
	
	\begin{equation}
		\begin{array}{l}
			S_k = (c_{k1}, c_{k2}, \cdots, c_{kn})	\\
			S_l = (c_{l1}, c_{l2}, \cdots, c_{ln})	
		\end{array}
	\end{equation}

	Em seguida, um inteiro $p$ é obtido, também aleatoriamente, entre 1 e $n - 1$ [p = [$1$, $n$)]. Lembre-se que $n$ é a ordem da matriz $H$ e, portanto, a quantidade de coeficientes no \emph{string} $S_i$. A função de $p$ é determinar em qual posição (\emph{locus}) do cromossomo acontecerá a alteração.
	
	O operador cria o novo par ($S^{'}_k$, $S^{'}_l$):
	
	\begin{equation}
		\begin{array}{l}
			S^{'}_k = (c_{k1}, c_{k2}, \cdots, c^{'}_{kp} c_{k,p+1}, \cdots, c_{kn})	\\
			S^{'}_l = (c_{l1}, c_{l2}, \cdots,  c^{'}_{lp} c_{l,p+1}, \cdots, c_{ln}),	\\
			
		\end{array}
	\end{equation}
	onde
	
	\begin{equation}
		\begin{array}{l}
			c^{'}_{kp} = f c_{kp} + (1 - f) c_{lp}     \\
			c^{'}_{lp} = (1 - f) c_{kp} + f c_{lp}.
		\end{array}
	\end{equation}
	
	O parâmetro $f$ faz o papel da mistura que cria nova informação. Ele é gerado aleatoriamente com valores entre zero e um. Nesse caso os valores limite não estão inclusos [f = (0,1)]. Dessa maneira há garantia de mistura.
	
	Esse operador só age em uma certa fração da população, dada por uma probabilidade $p_c$ que, em geral, é grande (70$-$75\%). O restante da população não é alterado.

%-----------------
\textbf{Exemplo}.
%-----------------

Na figura \ref{fig:cross2004_tabelaAntes} há dois cromossomos de tamanho $n = 6$. A posição onde ocorrerá a alteração dos valores foi obtida aleatoriamente entre $p = [1,6)$, e, para esse caso, vale $p = 4$. O valor de $S_k$ na posição $p = 4$ é $c_{k4} = 0,80$, e para $S_l$ é $c_{l4} = 0,39$. Para $p + 1$ os valores são $c_{k5} = 0,15$ e $c_{l5} = 0,89$.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.70\textwidth]{figs/materiais_metodo/autovalores_com_ga/cross2004_tabelaAntes.png}
	\caption{Exemplo do \emph{crossover} de \cite{metodo2004}. Indivíduos antes da reprodução.}
	\label{fig:cross2004_tabelaAntes}
\end{figure}

O parâmetro $f$ teve seu valor determinado aleatoriamente como $f = 0,62$. Os valores de $c^{'}_{k4}$ e $c^{'}_{l4}$ ficam:

\begin{equation}\label{eq:ck4}
	\begin{array}{lccl}
		c^{'}_{kp} = & f c_{kp} & + & (1 - f) c_{lp} 						\\
		c^{'}_{k4} = & 0,62 c_{k4} & + & (1 - 0,62) c_{l4} 			\\
		c^{'}_{k4} = & 0,62 * 0,80 & + & 0,38 * 0,39 						\\		
		c^{'}_{k4} = & 0,496 & + & 0,1482	\\		
		c^{'}_{k4} = & 0,6442 &  & 
	\end{array}
\end{equation}

\begin{equation}\label{eq:cl4}
	\begin{array}{lccl}
		c^{'}_{lp} = & (1-f) c_{kp} & + & f c_{lp} 						\\
		c^{'}_{l4} = & (1-0,62) c_{k4} & + & 0,62 c_{l4} 						\\
		c^{'}_{l4} = & 0,38 * 0,80 & + & 0,62 * 0,39 						\\
		c^{'}_{l4} = & 0,304 & + & 0,2418 						\\
		c^{'}_{l4} = & 0,5458 &  & 
	\end{array}
\end{equation}

Finalmente, os valores para a posição $p = 4$ nos novos indivíduos $S^{'}_k$ e $S^{'}_l$ são

\begin{equation}\label{eq:cross2004_novo_valor_sk}
	\begin{array}{ll}
	\mbox{Novo valor na posição 4 de  } S^{'}_k & = c^{'}_{kp} c_{k,p+1} \\
								& = c^{'}_{k4} c_{k5} \\
								& = 0,6442 * 0,15	\\
								& = 0,09663	\\
								& \approx 0,1
	\end{array}
\end{equation}

\begin{equation}\label{eq:cross2004_novo_valor_sl}
	\begin{array}{ll}
	\mbox{Novo valor na posição 4 de  } S^{'}_l & = c^{'}_{lp} c_{l,p+1} \\
								& = c^{'}_{l4} c_{l5} \\
								& = 0,5458 * 0,89	\\
								& = 0,485762 \\
								& \approx  0,49
	\end{array}
\end{equation}


Na figura \ref{fig:cross2004_tabelaDepois} há os dois novos indivíduos.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.70\textwidth]{figs/materiais_metodo/autovalores_com_ga/cross2004_tabelaDepois.png}
	\caption{Exemplo do \emph{crossover} de \cite{metodo2004}. Indivíduos depois da reprodução.}
	\label{fig:cross2004_tabelaDepois}
\end{figure}

%----------------------------------------------------
\subsubsection{\emph{Crossover} em \cite{metodo2011}}	
%----------------------------------------------------

	A representação cromossomial usada em \cite{metodo2011} é a mesma de \cite{metodo2004}, portanto, o par ($S_k$, $S_l$) é igual, assim como a probabilidade $p_c$:
	
	\begin{equation}
		\begin{array}{l}
		S_k = (c_{k1}, c_{k2}, \cdots, c_{kn})	\\
		S_l = (c_{l1}, c_{l2}, \cdots, c_{ln})	
		\end{array}
	\end{equation}
	
	Diferentemente de \cite{metodo2004}, utiliza-se o \emph{crossover} de dois pontos. Aleatoriamente escolhe-se dois inteiros, $o$ e $p$, cuja função é determinar a região do cromossomo que sofrerá miscigenação. O valor em $o$ indica o primeiro gene, e $p$ o último. Portanto, todos os genes entre os dois, incluindo eles próprios, sofrerão a ação do \emph{crossover} ($o <= c_i <= p$, $p \geq o$). Os novos indivíduos são ($S^{'}_k$, $^{'}S_l$)
	
	\begin{equation}
		\begin{array}{l}
			S^{'}_k = (c_{k1}, c_{k2}, \cdots, c^{'}_{ko}, \cdots , c^{'}_{kp}, c_{k,p+1}, \cdots, c_{kn})	\\
			S^{'}_l = (c_{l1}, c_{l2}, \cdots, c^{'}_{lo}, \cdots , c^{'}_{lp}, c_{l,p+1}, \cdots, c_{ln}).	
		\end{array}
	\end{equation}
	
	Para todos genes selecionados, a transformação ocorre da seguinte maneira ($i = o, o + 1, \cdots, p$):
	
	\begin{equation}
		\begin{array}{l}
			c^{'}_{ki} = f_c c_{ki} + (1 - f_c) c_{li}     \\
			c^{'}_{li} = (1 - f_c) c_{ki} + f_c c_{li}
		\end{array}
	\end{equation}
	onde $f_c$ é dado por
	
	\begin{equation}
		f_c = 0,75 + 0,25r,
	\end{equation}
	sendo $r$ um número aleatório ($0 \leq r \leq 1$). Assim como o parâmetro $f$ de \cite{metodo2004}, $f_c$ faz o papel da mistura que cria nova informação.
	
	\textbf{Exemplo}.
	
	
	Usei os mesmos indivíduos da figura \ref{fig:cross2004_tabelaAntes}. Os parâmetros $o$ e $p$ foram escolhidos no intervalo [1,6] e têm valores $o = 2$ e $p = 4$. Portanto, no \emph{string} $S_k$ os elementos que sofrerão alteração são $c_{k2} = 0,47$, $c_{k3} = 0,52$ e $c_{k4} = 0,80$. Eles se misturarão com os elementos $c_{l2} = 0,33$, $c_{l3} = 0,37$ e $c_{l4} = 0,39$ de $S_l$. Aleatoriamente obtive $r = 0,2$, que leva a $f_c = 0,80$.
	
	\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.70\textwidth]{figs/materiais_metodo/autovalores_com_ga/cross2011_tabelaAntes.png}
	\caption{Exemplo do \emph{crossover} de \cite{metodo2011}. Indivíduos antes da reprodução.}
	\label{fig:cross2011_tabelaAntes}
\end{figure}
	
	Os elementos $c^{'}_{ki}$ são:
	
	\begin{equation}
		\begin{array}{llcl}
			c^{'}_{k2}	& = f_c c_{k2} 		& + & (1- f_c) c_{l2} \\
									& = 0,80 * 0,47		& + &	(1 - 0,80) * 0,33 \\
									& = 0,376					& + & 0,2 * 0,33	\\
									& = 0,376					& + & 0,066	\\
									& = 0,442 \\
									& \approx 0,44
		\end{array}
	\end{equation}
	
	
	\begin{equation}
		\begin{array}{llcl}
			c^{'}_{k3}	& = f_c c_{k3} 		& + & (1- f_c) c_{l3} \\
									& = 0,80 * 0,52		& + &	(1 - 0,80) * 0,37 \\
									& = 0,416					& + & 0,2 * 0,37	\\
									& = 0,416					& + & 0,074	\\
									& = 0,49
		\end{array}
	\end{equation}
	
	
	\begin{equation}
		\begin{array}{llcl}
			c^{'}_{k4}	& = f_c c_{k4} 		& + & (1- f_c) c_{l4} \\
									& = 0,80 * 0,80		& + &	(1 - 0,80) * 0,39 \\
									& = 0,64					& + & 0,2 * 0,39	\\
									& = 0,64					& + & 0,078	\\
									& = 0,718 \\
									& \approx 0,72
		\end{array}
	\end{equation}
	
	
	Os elementos $c^{'}_{li}$ são:
	
	\begin{equation}
		\begin{array}{llcl}
			c^{'}_{l2}	& = (1 - f_c) c_{k2} 		& + & f_c c_{l2} \\
									& = (1 - 0,80) * 0,47		& + &	0,80 * 0,33 \\
									& = 0,2 * 0,47					& + & 0,264	\\
									& = 0,094					& + & 0,264	\\
									& = 0,358 \\
									& \approx 0,36
		\end{array}
	\end{equation}
	
	\begin{equation}
		\begin{array}{llcl}
			c^{'}_{l3}	& = (1 - f_c) c_{k3} 		& + & f_c c_{l3} \\
									& = (1 - 0,80) * 0,52		& + &	0,80 * 0,37 \\
									& = 0,2 * 0,52					& + & 0,296	\\
									& = 0,104								& + & 0,296	\\
									& = 0,40									
		\end{array}
	\end{equation}
	
	
	\begin{equation}
		\begin{array}{llcl}
			c^{'}_{l4}	& = (1 - f_c) c_{k4} 		& + & f_c c_{l4} \\
									& = (1 - 0,80) * 0,80		& + &	0,80 * 0,39 \\
									& = 0,2 * 0,80					& + & 0,312	\\
									& = 0,16								& + & 0,312	\\
									& = 0,472 \\
									& \approx 0,47
		\end{array}
	\end{equation}
	
	Os novos indivíduos estão na figura \ref{fig:cross2011_tabelaDepois}.
		
	\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.70\textwidth]{figs/materiais_metodo/autovalores_com_ga/cross2011_tabelaDepois.png}
	\caption{Exemplo do \emph{crossover} de \cite{metodo2011}. Indivíduos depois da reprodução.}
	\label{fig:cross2011_tabelaDepois}
\end{figure}
	
	
%----------------------------------------------------
\subsubsection{\emph{Crossover} utilizado}
\label{sec:crossover_utilizado}
%----------------------------------------------------

	A quantidade de nova informação não é escalável com o tamanho do cromossomo no \emph{crossover} de \cite{metodo2004}. Ele altera apenas uma posição (locus) de cada indivíduo, independentemente do tamanho do cromossomo. Por exemplo, se a ordem do Hamiltoniano for $n = 100$, o \emph{string} terá 100 elementos, mas apenas um sofrerá alteração. O mesmo aconteceria para $n = 1.000$, 10.000 e assim por diante.
	
	Ainda sobre o artigo de 2004, é impossível haver troca de informação na última posição. O parâmetro $p$, obtido aleatoriamente, dá a posição que ocorrerá o \emph{crossover}. Porém, parte do cálculo envolve os elementos $c_{k,p+1}$ e $c_{l,p+1}$. Note o índice $p+1$. Como a posição máxima é $n$, o maior índice possível para estes elementos é $p + 1 = n$, impondo o limite $p \leq n - 1$. Nos exemplos apresentados, $n = 6$, $p \leq 5$ e, portanto, a posição $6$ nunca será escolhida.
	
	Isso pode dificultar a busca. Suponhe que uma solução precise do valor 23 no último coeficiente do cromossomo ($c_n = 0,23$). Se nenhum indivíduo da população inicial já tiver nascido com ele, esse valor nunca aparecerá por meio do \emph{crossover}. Resta como esperança a Mutação, porém, por definição, ela tem baixa probabilidade \cite{Linden2008}. Também não há garantia de que, após muitas gerações com sucessivas operações de \emph{crossover}, mutação e seleção, haverá um indivíduo na população que, além de ter 0,23 na última posição, possua os outros $(n-1)$ primeiros elementos necessários.
		
		O \emph{crossover} de \cite{metodo2004} é um caso especial do \emph{crossover} de \cite{metodo2011}. O operador de reprodução de \cite{metodo2011} é o clássico \emph{crossover} de dois pontos \cite{Linden2008}. Nele, $p \geq o$, e, se $o = p$, há mistura em apenas uma posição do \emph{string}, exatamente o que acontece em \cite{metodo2004}. Como $1 \leq o \leq n$ e $1 \leq p \leq n$, o último gene também está sujeito à operação, e o problema citado no parágrafo anterior não existe.
		
	Pelo que expus acima, escolhi utilizar o \emph{crossover} de \cite{metodo2011}, mas com uma pequena modificação. No cálculo dos novos coeficientes $c^{'}_{i}$, invés do parâmetro $f_c$, usei o $f$ conforme definido em \cite{metodo2004}. O $f$ pode variar entre $0$ e $1$, enquanto o $f_c$, além de necessitar do parâmetro adicional $r$, é limitado apenas entre $0,75$ e $1$. Assim, acredito que $f$ seja mais abrangente como parâmetro de mistura e criação de nova informação.
	
	\textbf{\emph{Crossover} utilizado.}
	
	A seguir apresento sinteticamente a estrutura do \emph{crossover} utilizado. Um par de indivíduos $(S_k, S_l)$
	
	\begin{equation}
		\begin{array}{l}
			S_k = (c_{k1}, c_{k2}, \cdots, c_{kn})	\\
			S_l = (c_{l1}, c_{l2}, \cdots, c_{ln})	
		\end{array}
	\end{equation}
	é obtido aleatoriamente da população. Com probabilidade $p_c$, a operação de \emph{crossover} acontece. Dois pontos de corte $o$ e $p$ são obtidos, também aleatoriamente, gerando os novos \emph{strings} $S^{'}_k$ e $S^{'}_l$ na forma
		
	\begin{equation}
		\begin{array}{l}
			S^{'}_k = (c_{k1}, c_{k2}, \cdots, c^{'}_{ko}, \cdots , c^{'}_{kp}, c_{k,p+1}, \cdots, c_{kn})	\\
			S^{'}_l = (c_{l1}, c_{l2}, \cdots, c^{'}_{lo}, \cdots , c^{'}_{lp}, c_{l,p+1}, \cdots, c_{ln}),
		\end{array}
	\end{equation}
	onde
	
	\begin{equation}
		\begin{array}{l}
			c^{'}_{ki} = f c_{ki} + (1 - f) c_{li}     \\
			c^{'}_{li} = (1 - f) c_{ki} + f c_{li}
		\end{array}
	\end{equation}
	e
	
	\begin{equation}
	0 \leq f \leq 1 \mbox{       (obtido aleatoriamente)}
	\end{equation}

%-------------------------------------------------------
\subsection{Mutação}
%-------------------------------------------------------

	A operador Mutação é semelhante nos dois artigos. Todos os cromossomos estão sujeitos à mutação. Se um indivíduo $k$ sofre mutação no gene $q$, o antigo valor $c^{'}_{kq}$ é alterado para $c^{''}_{kq}$ com a seguinte equação:

		\begin{equation}\label{eq:mutacao}
			c^{''}_{kq} = c^{'}_{kq} + (-1)^{L} r \Delta,
		\end{equation}
		onde $L$ é um número inteiro, $r$ um número aleatório ($0 \leq r \leq 1$) e $\Delta$ é a intensidade da mutação.
		
		
	Não ficou claro para mim qual a relação entre a probabilidade $p_m$ e como será a mutação no artigo \cite{metodo2004}. Os autores dizem que todos os \emph{indivíduos} estão sujeitos ao operador, mas não citam quais \emph{genes} podem sofrer mutação. Essa informação está explícita em \cite{metodo2011}, que permite mutação, caso aconteça, em apenas um gene de cada indivíduo. Ou seja, se houver mutação logo no primeiro gene de um cromossomo, o algoritmo parte para o próximo indivíduo.
	
	Assumi que no artigo \cite{metodo2004} os autores utilizaram o operador clássico. Conforme a literatura \cite{Mitchell98, Linden2008} o operador clássico de mutação age com probabilidade $p_m$ em cada gene, de maneira individual e independente. Ou seja, se um gene $c_{k,j}$ sofreu ou não mutação, essa informação não é utilizada para avaliar a ocorrência de mutação no próximo gene $c_{k,j+1}$. Portanto, a probabilidade de cada \emph{gene} sofrer mutação é $p_m$, mas a probabilidade $P_m$ de um \emph{indivíduo} sofrer mutação é, na verdade, $P_m = n*p_m$. Quanto maior o $n$, mais provável ocorrer a mutação, o que me parece razoável. Mutação é causada principalmente por erros de cópia do DNA. Quanto maior a fita, mais chance de acontecer erro.

	Há diferença na intensidade da mutação $\Delta$. No trabalho de 2004 ela é pequena ($10^{-2}-10^{-3}$) e mantida constante. Já no segundo artigo ela é proporcional ao melhor \emph{fitness} $f_t$ da geração atual $t$, e dada pela equação \ref{eq:Delta2011}. Como o \emph{fitness} começa pequeno e termina próximo de 1, $\Delta \rightarrow 0$ a medida que $f \rightarrow 1$.

\begin{equation}\label{eq:Delta2011}
	\Delta^{(t)}_m =  1 - f_t.
\end{equation}	

	Não fiquei confortável com a definição da equação \ref{eq:Delta2011}, por isso usei a intensidade $\Delta$ constante de \cite{metodo2004}. No início de um GA a criação de variabilidade genética é dominada pelo \emph{crossover}. No final, como os indivíduos são parecidos, fica a cargo da mutação fazer isso. A intensidade da mutação deve ser pequena e, se não for constante, é desejável que cresça com o tempo, justamente porque o papel da mutação passa a ser dominante na variabilidade comparado com o \emph{crossover} \cite{Linden2008}. Os autores de \cite{metodo2011} fazem o inverso. Como dito anteriormente, $\Delta$ diminui com o tempo, mas eles não justificam porque optaram por esse comportamento.
	
	Com relação à probabilidade de mutação, optei novamente a favor de \cite{metodo2004}. Ambos os trabalhos utilizam valor constante de $p_m$. Entretanto, em \cite{metodo2011} $p_m$ é inversamente proporcional ao tamanho do cromossomo $n$ (equação \ref{eq:probM2011}). Na prática, quanto maior a ordem $n$ do Hamiltoniano, menor a probabilidade de mutação, e no artigo não há justificativa para essa escolha. Fiquei com a probabilidade constante, discutida em livros tradicionais de GA \cite{Mitchell98, Linden2008}.

	\begin{equation}\label{eq:probM2011}
		p_m = 4.0/n
	\end{equation}


	\textbf{Mutação utilizada.}
	
	Abaixo resumo a estrutura da Mutação implementada na dissertação.
	
	
	\begin{itemize}
		\item \textbf{Probabilidade de mutação $p_m$}
			\begin{itemize}
				\item Constante.
				\item Um dos parâmetros do algoritmo.
				\item Pode ter qualquer valor $0 \leq p_m \leq 1$.
			\end{itemize}
		\item \textbf{Equação da mutação}.
			\begin{itemize}
				\item No indivíduo $S$, transforma o valor $c^{'}_{kq}$ do gene $q$ no novo valor $c^{''}_{kq}$.
				\item Equação: $c^{''}_{kq} = c^{'}_{kq} + (-1)^{L} r \Delta$
				\item Parâmetro $L$: inteiro aleatório.
				\item Parâmetro $r$: aleatório ($0 \leq r \leq 1$).
				\item Intensidade de mutação $\Delta$: Constante. Valores pequenos ($10^{-3}-10^{-2}$).
			\end{itemize}
	\end{itemize}
	

%-------------------------------------------------------
\subsection{Fluxograma do algoritmo implementado}
%-------------------------------------------------------

	O algoritmo genético seguiu a estrutura de um GA básico \cite{Mitchell98, Linden2008}. Após gerar a população inicial, Avaliação, Seleção, Crossover e Mutação são executados nessa sequência até que uma condição de parada seja atingida.
	
	Na figura \ref{fig:fluxo} está o fluxograma. Ele não é um diagrama completo do \emph{software} desenvolvido, mas é útil para ter a visão geral do algoritmo.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{figs/materiais_metodo/autovalores_com_ga/fluxo.png}
	\caption{Fluxo algoritmo genético}
	\label{fig:fluxo}
\end{figure}


%========================================================
\section{\emph{Software}}
%========================================================

	O \emph{software} utilizado foi totalmente desenvolvido por mim, e há razões metodológicas que justificam essa escolha. Obtive bons resultados criando os próprios programas nos estudos iniciais de GA. Eles foram fundamentais para que eu soubesse exatamente o que estava acontecendo durante a execução. Quis ter esse controle total também sobre o programa que executaria o GA proposto para essa dissertação. Ele foi escrito em Linguagem C, utilizando apenas quatro bibliotecas padrão: \texttt{stdio.h}, \texttt{stdlib.h}, \texttt{time.h} e \texttt{math.h}. Portanto, é totalmente portável para os sistemas operacionais que possuem um compilador C$++$. Além disso, C é a linguagem nativa da arquitetura CUDA, o que facilitará sua paralelização.
	
	Tive muito cuidado com a confiabilidade dos resultados. Quando opta-se por não gerá-la automaticamente, a \emph{semente} dos números pseudo-aleatórios é um dos parâmetros de entrada. Duas execuções com os mesmos parâmetros, incluindo a semente, levam a exatamente os mesmos resultados. Por isso nas tabelas e gráficos deixei explícito seu valor. Os gráficos encontrados em \cite{metodo2004} e \cite{metodo2011} referem-se ao maior \emph{fitness} (e $\rho$ associado) de cada geração. O programa gera essa informação, mas também exibe as médias dessas variáveis. De acordo com \cite{Mitchell98}, uma teoria geral para entender e prever o comportamento dos GAs seria análoga à Mecânica Estatística na Física. Ao contrário de lidar com grande número de componentes do sistema, como a composição genética exata de cada população, tal abordagem trabalha com uma estatística mais ``macroscópica'', como o \emph{fitness} médio da população. Portanto, tanto os critérios de parada do programa quanto a minha análise foram baseadas em médias.
	
	Para utilizar o \emph{software} basta baixar o código e compilar o arquivo \texttt{Serial\_novo.c} (será necessário alterar o diretório no \emph{include} das bibliotecas que desenvolvi). O código está disponível na internet para qualquer um utilizar, testar e, inclusive melhorar\footnote{\texttt{https://github.com/prietoab/msc\_code}}. Caso isso aconteça, peço apenas que cite essa dissertação.
	
		A execução se dá via linha de comando passando os parâmetros necessários. Porém, como são muitos parâmetros, é aconselhável a utilização de um arquivo de \emph{script}. Assim é possível criar processos de varredura para variar os parâmetros desejados ou repetir várias execuções. Fiz isso para automatizar o estudo e ter dados suficientes para análise. Na figura \ref{fig:script_windows} há um exemplo de \emph{script} Windows para fazer execuções variando o número de genes.
			
		\begin{figure}[htbp]
			\centering
				\includegraphics{figs/materiais_metodo/software/script_windows.png}
			\caption{Exemplo de \emph{script} Windows para fazer execuções variando o número de genes.}
			\label{fig:script_windows}
		\end{figure}

	Não é necessário ter uma matriz para execução. Através do parâmetro \emph{Tamanho do cromossomo} (seção \ref{sec:listaParametros}) o programa gera automaticamente uma matriz de Coope \cite{Coope1977}, definida na equação \ref{eq:MatrizCoope}. Essa matriz foi utilizada nos testes de \cite{metodo2011}.
	
	\begin{equation}\label{eq:MatrizCoope}
		\begin{array}{ccl}
			H(i,i) = 2i - 1 			& , & i = 1, 2, ..., n. \\
														&		&		\\
			H(i,j) = H(j,i) = 1		& , & i \neq j; \\
														&		& i = 1, 2, ..., n; \\
														&		& j = 1, 2, ..., n.
		\end{array}
	\end{equation}
	
%---------------------------------------------------
\subsection{Informações de saída}
%---------------------------------------------------	
		
Há cinco grupos de informações na saída do programa. Usados em conjunto dão um panorama geral do algoritmo genético. Para apenas um deles (Estatística) um arquivo texto é gerado automaticamente. Os outros são exibidos na tela. Para alterar a saída padrão para um arquivo texto, é necessário utilizar o caractere de redirecionamento da saída padrão. No Windows, Linux e Unix esse caractere é o ``>''. No Linux, por exemplo, o comando ``\texttt{ls > dirs.txt}'' lista o conteúdo do diretório atual e armazena no arquivo \texttt{dirs.txt}.

\begin{enumerate}

	\item \textbf{Cabeçalho}
	
		Contém todos os parâmetros de execução recebidos na linha de comando. Impresso na tela.
	
	\item \textbf{Comportamento do \emph{fitness}}
	
		Imprime na tela, para cada geração, além de alguns parâmetros de execução, as seguintes informações: 
		
		\begin{itemize}
			\item $\rho$ mínimo
			\item $\rho$ médio (<$\rho$>)
			\item \emph{fitness} médio (<\emph{fitness}>)
			\item Maior \emph{fitness}
			\item $\rho$ associado ao maior \emph{fitness}
			\item <$|\nabla \rho|^2$>
			\item Posição do melhor indivíduo
		\end{itemize}

	\item \textbf{Tempos de processamento}
	
		Imprime na tela uma estimativa para o tempo de processamento (em \emph{clocks}) para cada operador. Se o programa foi executado por 200 gerações, haverá 200 tempos de processamento para o \emph{fitness}, seleção, \emph{crossover} e mutação.
		
	\item \textbf{Geração final}
	
				Impressão de todos os indivíduos da última geração. 
	
	\item \textbf{Estatística}
	
				A cada execução é criado (ou atualizado caso já exista) um arquivo chamado \texttt{estatistica.txt}. Nele, além de todos os parâmetros, há informações relacionadas à geração que atingiu algum critério de parada. Por exemplo, além do próprio número da última geração, há o \emph{fitness} médio, o maior \emph{fitness}, o $\rho$ associado ao maior \emph{fitness}, o $\rho$ médio e o tempo total de processamento do programa.
	
\end{enumerate}
	
%---------------------------------------------------
\subsection{Lista dos arquivos fonte}
%---------------------------------------------------
	
	O programa é pequeno ($\approx$ 2500 linhas), e está distribuído em seis arquivos, um principal e cinco bibliotecas:
	
	\begin{itemize}
		\item \textbf{Serial\_novo.c}
		
		Arquivo principal. Contém o fluxo do GA (figura \ref{fig:fluxo}).
		
		\item \textbf{Estruturas.h}
		
		Contém as estruturas de dados e uma função que retorna automaticamente o parâmetro $\lambda$ do \emph{fitness} (seção \ref{sec:eq_lambda}).
		
		\item \textbf{Algebra\_Linear\_serial.h}
		
		Mutiplicação e subtração de matrizes.
		
		\item \textbf{Estatistica.h}
		
		Média, variância e desvios do Quociente de Rayleigh.
		
		\item \textbf{Auxiliares\_serial.h}
		
		Números pseudo-aleatórios, alocação de memória para indivíduos na população.
		
		\item \textbf{GA\_Serial.h}
		
		Contém as funções do Algoritmo Genético. A maoria do código está nessa biblioteca.	
		
	\end{itemize}
					
%---------------------------------------------------
\subsection{Lista dos parâmetros de execução}
\label{sec:listaParametros}
%---------------------------------------------------
	\begin{enumerate}
		\item \textbf{Código da máquina}.
		
				Número inteiro, utilizado para identificar o computador que o programa foi executado. Útil para comparar as execuções em computadores diferentes. Por exemplo, se há quatro computadores A, B, C e D, é possível classificá-los como A = 0, B = 1, C = 2, D = 3.
				
		\item \textbf{Serial ou Paralelo}?
		
				Número inteiro. Determina se a execução será serial (= 0) ou paralela (= 1). A atual versão permite apenas execução serial. Portanto, esse parâmetro pode ser fixado em zero.
				
		\item \textbf{Tamanho do cromossomo (ordem da matriz de Coope)}.
		
				Número inteiro. Determina a ordem da matriz de Coope. Inserir 200 nesse parâmetro gera uma matriz de Coope de tamanho 200 x 200.
			
		\item \textbf{Quantidade máxima de gerações}.
		
				Número inteiro. Um dos critérios de parada. Para evitar que o programa entre em um \emph{loop} infinito caso não haja convergência para uma solução. Se definida como 100, o programa executará, no máximo, 100 iterações de Avaliação, Seleção, \emph{Crossover} e Mutação.
		
		\item \textbf{Quantidade de indivíduos na população}.
		
		Número inteiro. Determina a quantidade de indivíduos em cada população.
		
		\item \textbf{Tipo do Fitness}.
		
		Número inteiro. O programa pode trabalhar com cinco tipos de \emph{fitness}. Dois deles são os apresentados na seção \ref{sec:fitness_metodo}. Qualquer código diferente dos apresentados abaixo faz com que o \emph{fitness} seja definido como $f = -1$.
		
			\begin{itemize}
				\item Tipo  0:
				
					\begin{equation}
					f = e^{-\lambda(\rho - E_L)^2}
					\end{equation}
				
				\item Tipo 1:
				
					\begin{equation}
					f = e^{-\lambda |\nabla \rho|^2}
					\end{equation}
					
				\item Tipo 2:
				
					\begin{equation}
					f = e^{-\lambda [(\rho - E_L)^2 + |\nabla \rho|^2]}
					\end{equation}
					
				\item Tipo 3:
				
					\begin{equation}
					f = e^{-\lambda |\nabla \rho|}
					\end{equation}
		
			\item Tipo 4:
				
					\begin{equation}
					f = e^{-\lambda [(\rho - E_L)^2 + |\nabla \rho|]}
					\end{equation}
			\end{itemize}
			
		\item \textbf{Tipo do Fitness Paralelo}.
		
				Número inteiro. A atual versão permite apenas execução serial. Portanto, esse parâmetro pode ser fixado em zero.
		
		\item \textbf{Tamanho do Torneio}
		
			Número inteiro. Define a quantidade de indivíduos selecionados para o torneio na Seleção.
		
		\item \textbf{Probabilidade do \emph{Crossover}}.
		
			Número real. Define, em porcentagem, a probabilidade de \emph{Crossover}. Exemplo: 80.5 = 80.5\%.
		
		\item \textbf{Quantidade de Pontos de Corte}.
		
			Número inteiro. Na versão atual a quantidade de pontos de corte foi fixada em dois conforme o operador de \emph{crossover} definido na seção \ref{sec:crossover_utilizado}. Pode ser mantido como zero.
		
		\item \textbf{Probabilidade de Mutação}.
		
		Número real. Define, em porcentagem, a probabilidade de mutação. Exemplo: 12.7 = 12.7\%.
		
		\item \textbf{Intensidade da Mutação - $\Delta$}.
		
			Número real. Define o parâmetro $\Delta$ utilizado no \emph{crossover}. É dividido por dez. Exemplo: $1.2$ no parâmetro $\rightarrow 0.12$ no $\Delta$.
		
		\item \textbf{Valor para $\lambda$}.
		
		Número real. Define o valor do parâmetro $\lambda$ do \emph{fitness}. Se for configurado como $-1$, um valor adequado para $\lambda$ é gerado automaticamente.
		
		\item \textbf{Valor para $E_L$}.
		
		Número real. Define um limite inferior para o autovalor mínimo ($E_0$) nos \emph{fitness} de tipo 0, 2 e 4. 
		
		\item \textbf{Precisão - $\xi$}.
		
		Número real. Define a precisão dos critérios de parada. O programa termina se a variável alvo é menor ou igual a $\xi$. Depende do tipo de \emph{fitness}.
		
		Condições de parada em função do \emph{fitness} ($<x>$ significa valor médio de $x$):
				
		\begin{itemize}
			\item Fitness tipos 0, 2 e 4:
			
			\begin{equation}
				\begin{array}{ccll}
				<|\nabla \rho_i|^2> & \leq & \xi & \mbox{  ou} \\
				| <\rho_i> - E_L | & \leq & \xi &
				\end{array}
			\end{equation}
			
			
			\item Fitness tipos 1 e 3:
			
			\begin{equation}
				\begin{array}{ccll}
					<|\nabla \rho_i|^2> & \leq & \xi &
				\end{array}
			\end{equation}
			
		\end{itemize}
		
		\item \textbf{Imprime comportamento do \emph{Fitness}}?
		
		Se configurado como Verdadeiro (1), imprime na saída padrão as variáveis de interesse para estudar o comportamento do \emph{fitness}. 
		
			0: \emph{Falso}. Não imprime.
			
			1: \emph{Verdadeiro}. Imprime.
		
		\item \textbf{Imprime tempos de execução}?
		
			Número inteiro. Se configurado como Verdadeiro (1), imprime na saída padrão os tempos estimados de execução (em \emph{clocks} do processador) das funções e operadores.
			
			
			0: \emph{Falso}. Não imprime.
			
			1: \emph{Verdadeiro}. Imprime.
			
		
		\item \textbf{Gera nova semente para números pseudo-aleatrórios}?
		
		Número inteiro. Se configurado como Verdadeiro (1), o programa cria uma nova semente para os números pseudo-aleatórios. Caso contrário, a semente definida no próximo parâmetro é utilizada.
		
		0: \emph{Falso}. Utiliza semente definida no parâmetro \emph{Semente}.
		
		1: \emph{Verdadeiro}. Cria uma nova semente. O parâmetro \emph{Semente} é ignorado.
		
		\item \textbf{Semente dos números pseudo-aleatrórios}.
		
		Número inteiro. Define a semente dos números pseudo-aleatórios. Depende do parâmetro anterior.
		
		\item \textbf{Tipo do cálculo de $\nabla \rho$}.
		
		Deve ser configurado como 1.
		
		Nas versões iniciais $\nabla \rho$ era calculado literalmente como na equação \ref{eq:grad_rho_metodo}, exigindo o uso de uma matriz identidade ($I$) da ordem do Hamiltoniano. A equação foi reescrita internamente de modo que $I$ não fosse necessária, liberando memória e fazendo menos operações. Usar ou não $I$ leva aos mesmos resultados.
		
		0: Utiliza matriz identidade.
		
		1: Não utiliza matriz identidade (libera memória e faz menos operações).
		
	\end{enumerate}